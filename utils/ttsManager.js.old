// utils/ttsManager.js
const https = require("https");
const googleTTS = require("google-tts-api");
const {
  createAudioPlayer,
  createAudioResource,
  AudioPlayerStatus,
  entersState,
} = require("@discordjs/voice");

function streamFromUrl(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => resolve(res)).on("error", reject);
  });
}

// Simple token-bucket rate limiter
function makeTokenBucket({ capacity, refillPerMs }) {
  return { capacity, refillPerMs, tokens: capacity, last: Date.now() };
}
function takeToken(bucket, cost = 1) {
  const now = Date.now();
  const delta = now - bucket.last;
  bucket.last = now;
  bucket.tokens = Math.min(bucket.capacity, bucket.tokens + delta * bucket.refillPerMs);
  if (bucket.tokens < cost) return false;
  bucket.tokens -= cost;
  return true;
}

class TTSManager {
  constructor() {
    this.guild = new Map(); // guildId -> state
  }

  _get(guildId) {
    if (!this.guild.has(guildId)) {
      this.guild.set(guildId, {
        connection: null,
        player: createAudioPlayer(),
        queue: [],
        playing: false,
        followChannelId: null,

        // Rate limiters
        userBuckets: new Map(),     // userId -> bucket
        guildBucket: makeTokenBucket({ capacity: 8, refillPerMs: 8 / 60000 }), // 8 msgs/min
      });
    }
    return this.guild.get(guildId);
  }

  setConnection(guildId, connection) {
    const s = this._get(guildId);
    s.connection = connection;
    s.connection.subscribe(s.player);

    // Auto-continue when audio ends
    s.player.on(AudioPlayerStatus.Idle, () => {
      s.playing = false;
      this._drain(guildId).catch(() => {});
    });
  }

  setFollowChannel(guildId, channelId) {
    const s = this._get(guildId);
    s.followChannelId = channelId;
  }

  getFollowChannel(guildId) {
    return this._get(guildId).followChannelId;
  }

  isConnected(guildId) {
    const s = this._get(guildId);
    return !!s.connection;
  }

  // Rate limits: per-user + per-guild
  allow(guildId, userId) {
    const s = this._get(guildId);

    // guild-level bucket: overall spam control
    if (!takeToken(s.guildBucket, 1)) return false;

    // user bucket: 2 messages per 20 seconds (burst 2)
    let b = s.userBuckets.get(userId);
    if (!b) {
      b = makeTokenBucket({ capacity: 2, refillPerMs: 2 / 20000 });
      s.userBuckets.set(userId, b);
    }
    return takeToken(b, 1);
  }

  async enqueue({ guildId, text }) {
    const s = this._get(guildId);
    if (!s.connection) return false;

    // Push into queue
    s.queue.push(text);

    // Start draining if not already playing
    if (!s.playing) {
      s.playing = true;
      await this._drain(guildId);
    }
    return true;
  }

  async _drain(guildId) {
    const s = this._get(guildId);
    if (!s.connection) return;

    // If already playing, donâ€™t start a new one
    if (s.player.state.status === AudioPlayerStatus.Playing) return;

    const next = s.queue.shift();
    if (!next) return;

    const url = googleTTS.getAudioUrl(next, {
      lang: "en",
      slow: false,
      host: "https://translate.google.com",
    });

    const stream = await streamFromUrl(url);
    const resource = createAudioResource(stream);

    s.player.play(resource);

    // Optional: wait a moment to ensure it begins
    try {
      await entersState(s.player, AudioPlayerStatus.Playing, 5000);
    } catch {
      // If it failed, try the next item
      s.playing = false;
      await this._drain(guildId);
    }
  }

  clearQueue(guildId) {
    const s = this._get(guildId);
    s.queue = [];
  }
}

module.exports = { TTSManager };
